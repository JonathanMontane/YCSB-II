package com.yahoo.ycsb.generator;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.HashSet;
import java.util.Properties;
import java.util.Vector;

import com.yahoo.ycsb.Utils;
import com.yahoo.ycsb.WorkloadException;

import org.apache.commons.codec.binary.Base64;


public class ThresholdDiscreteGenerator extends Generator{

	class Pair {
		public double _weight;
		public String _value;

		Pair(double weight, String value) {
			_weight = weight;
			_value = value;
		}
	}

	Vector<Pair> _values;
	String _lastvalue;

	public ThresholdDiscreteGenerator() {
		_values = new Vector<Pair>();
		_lastvalue = null;
	}

	/**
	 * Generate the next string in the distribution.
	 */
	public String nextString() {
		HashSet<String> validFields = new HashSet<String>();
		double val = Utils.random().nextDouble();

		for (Pair p : _values) {
			if (val < p._weight) {
				validFields.add(p._value);
			}
		}
		
		if(validFields.size() == 0){
			return nextString();
		}
		
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		ObjectOutputStream so;
		try {
			so = new ObjectOutputStream(bo);
			so.writeObject(validFields);
			so.flush();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return new String(Base64.encodeBase64(bo.toByteArray()));
	}

	/**
	 * If the generator returns numeric (integer) values, return the next value
	 * as an int. Default is to return -1, which is appropriate for generators
	 * that do not return numeric values.
	 * 
	 * @throws WorkloadException
	 *             if this generator does not support integer values
	 */
	public int nextInt() throws WorkloadException {
		throw new WorkloadException(
				"DiscreteGenerator does not support nextInt()");
	}

	/**
	 * Return the previous string generated by the distribution; e.g., returned
	 * from the last nextString() call. Calling lastString() should not advance
	 * the distribution or have any side effects. If nextString() has not yet
	 * been called, lastString() should return something reasonable.
	 */
	public String lastString() {
		if (_lastvalue == null) {
			_lastvalue = nextString();
		}
		return _lastvalue;
	}

	public void addValue(double weight, String value) {
		_values.add(new Pair(weight, value));
	}

	public void setup(Properties properties) {
		for (Object key : properties.keySet()) {
			String _key = key.toString();
			Double _value = Double.parseDouble(properties.getProperty(_key));
			_values.add(new Pair(_value, _key));
		}
	}

}
